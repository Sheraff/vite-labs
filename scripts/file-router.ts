import { createLogger, type Plugin } from 'vite'
import {
	// @ts-expect-error -- glob is not in the types yet
	glob,
	mkdir,
	readFile,
	writeFile,
} from 'node:fs/promises'
import path, { join } from 'node:path'
import { parseForESLint } from '@typescript-eslint/parser'
import { simpleTraverse } from '@typescript-eslint/typescript-estree'
import type { TSESLint } from '@typescript-eslint/utils'

const template = (routes: Array<[key: string, meta: string]>) => `// generated by file-router
/* eslint-disable */
import { lazy } from "react"

export type Routes = "${routes.map(r => r[0]).join('" | "')}"

export type RouteMeta = {
	title: string
}

export type Route = {
	Component: React.LazyExoticComponent<() => JSX.Element>
	meta: RouteMeta
}

export const ROUTES = {
${routes.map(([route, meta]) => `	"${route}": {
		Component: lazy(() => import("./pages/${route}/index.tsx")),
		meta: ${meta.split('\n').join('\n\t\t')},
	}`).join(',\n')}
} as const satisfies Record<Routes, Route>
`

export function fileRouter(): Plugin[] {
	const logger = createLogger('info', { prefix: '[file-router]' })
	let latestContent = ''
	const prefix = 'src/pages/'
	const suffix = '/index.tsx'

	async function generate() {
		const start = Date.now()
		let count = 0
		const routes: Array<[key: string, meta: string]> = []
		for await (const index of glob(`${prefix}*${suffix}`)) {
			count++
			const key = index.slice(prefix.length, -suffix.length)
			const source = await readFile(index, 'utf-8')
			const { ast, visitorKeys } = parseForESLint(source, {
				comment: false,
				filePath: index,
				loc: true,
				range: true,
				tokens: false,
			})
			let meta = `{ title: "${key}" }`
			const listener: TSESLint.RuleListener = ({
				ExportNamedDeclaration(node) {
					if (node.declaration?.type !== 'VariableDeclaration') return
					const decl = node.declaration.declarations[0]
					if (decl.type !== 'VariableDeclarator') return
					if (decl.id.type !== 'Identifier' || decl.id.name !== 'meta') return
					if (decl.init?.type !== 'ObjectExpression') throw new Error('Expected ObjectExpression')
					meta = source.slice(decl.init.range[0], decl.init.range[1])
				}
			})
			simpleTraverse(ast, {
				visitorKeys,
				visitors: listener as never
			})
			routes.push([key, meta])
		}
		logger.info(`scanned ${count} routes in ${Date.now() - start} ms`, { timestamp: true })

		const content = template(routes)

		if (latestContent === content) return routes
		latestContent = content

		await writeFile('./src/router.ts', content)

		return routes
	}

	let routes: [key: string, meta: string][] = []
	let dist = ''

	return [{
		name: 'file-router',
		enforce: 'pre',
		configureServer(server) {
			const listener = (file = '') => (file.includes(path.normalize('/src/pages/')) ? generate() : null)
			server.watcher.on('add', listener)
			server.watcher.on('change', listener)
			server.watcher.on('unlink', listener)
		},
		async buildStart() {
			routes = await generate()
		},
	}, {
		/*
		 * In "build" mode, we want to copy the index.html to the all the routes, so that
		 * a static file server can serve the routes.
		 */
		name: 'file-router-post',
		enforce: 'post',
		apply: 'build',
		outputOptions(options) {
			dist = options.dir!
		},
		async writeBundle() {
			const html = await readFile(join(dist, 'index.html'), 'utf-8')
			this.info('copying index.html to routes')
			for (const [route] of routes) {
				const dir = join(dist, route)
				await mkdir(dir, { recursive: true })
				const target = join(dir, 'index.html')
				await writeFile(target, html)
				this.info(target)
			}
		},
	}]
}
