import { parseSync, Visitor, type ObjectExpression } from "oxc-parser"
import { exec } from "node:child_process"
import { glob, mkdir, readFile, writeFile } from "node:fs/promises"
import { dirname, join, relative } from "node:path"
import { createLogger, type Plugin } from "vite"

type Image = [name: string, path: string]
type Route = [key: string, meta: { meta: string; images: Image[] }, git: string]

const template = (routes: Array<Route>) => `// generated by file-router
/* eslint-disable */
import { type JSX, lazy } from "react"
${routes
		.map(([, { images }]) => images.map(([name, path]) => `import ${name} from "${path}"`).join("\n"))
		.filter(Boolean)
		.join("\n")}

export type Routes = "${routes.map((r) => r[0]).join('" | "')}"

export type RouteMeta = {
	title: string
	image?: string
	description?: string
	tags?: string[]
}

export type GitMeta = {
	lastModified: number
	firstAdded: number
}

export type Route = {
	Component: React.LazyExoticComponent<() => JSX.Element>
	meta: RouteMeta
	git: GitMeta
}

export const ROUTES = {
${routes
		.map(
			([route, { meta }, git]) => `	"${route}": {
		Component: lazy(() => import("./pages/${route}/index.tsx")),
		meta: ${meta.split("\n").join("\n\t\t")},
		git: ${git},
	}`,
		)
		.join(",\n")}
} as const satisfies Record<Routes, Route>
`

async function getGitMeta(index: string) {
	const dir = dirname(index)

	// Get last modification time for the entire directory
	const lastModTime = new Promise<number>((resolve, reject) => {
		exec(`git log -1 --pretty="format:%ai" -- "${dir}"`, (error, stdout, stderr) => {
			if (error || stderr) return reject(error || stderr)
			const timestamp = stdout.trim() ? new Date(stdout.trim()).getTime() : 0
			resolve(timestamp || 0)
		})
	})

	// Get first commit time for the entire directory
	const firstAddTime = new Promise<number>((resolve, reject) => {
		exec(`git log --diff-filter=A --format="%ad" --date=iso --reverse -- "${dir}" | head -1`, (error, stdout, stderr) => {
			if (error || stderr) return reject(error || stderr)
			const timestamp = stdout.trim() ? new Date(stdout.trim()).getTime() : 0
			resolve(timestamp || 0)
		})
	})



	const git = `{\n\t\t\tlastModified: ${await lastModTime},\n\t\t\tfirstAdded: ${await firstAddTime}\n\t\t}`
	return git
}

type Context = {
	resolve: (source: string, importer?: string | undefined) => Promise<{ id: string } | null>
	addWatchFile: (id: string) => void
}

const IMAGES = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".ico", ".bmp", ".tiff", ".avif"]

function fileNameToJSVariable(name: string) {
	return name.replace(/[^a-zA-Z0-9]/g, "_")
}

async function getMeta(key: string, index: string, ctx?: Context) {
	let meta = `{ title: "${key}" }`
	let foundNode = false as ObjectExpression | false
	const images: Image[] = []
	const source = await readFile(index, "utf-8")
	try {
		const { program } = parseSync(index, source, {
			range: true,
		})
		const visitor = new Visitor({
			ExportNamedDeclaration(node) {
				if (foundNode) return
				if (node.declaration?.type !== "VariableDeclaration") return
				const decl = node.declaration.declarations[0]
				if (decl.type !== "VariableDeclarator") return
				if (decl.id.type !== "Identifier" || decl.id.name !== "meta") return
				if (decl.init?.type !== "ObjectExpression") throw new Error("Expected ObjectExpression")
				foundNode = decl.init
			},
		})
		visitor.visit(program)
	} catch (e) {
		console.error(e)
	}
	if (foundNode) {
		const start = foundNode.range![0]
		meta = source.slice(start, foundNode.range![1])
		if (ctx?.resolve) {
			for (let i = foundNode.properties.length - 1; i >= 0; i--) {
				const prop = foundNode.properties[i]
				if (prop.type !== "Property") throw new Error("Expected Property in meta object for static analysis")
				if (prop.value.type === "TemplateLiteral") continue // hopefully the expressions remain valid once we move this out
				if (prop.value.type === "ArrayExpression") continue // hopefully the elements remain valid once we move this out
				if (prop.value.type !== "Literal")
					throw new Error(`Expected Literal value in meta object for static analysis, got ${prop.value.type}`)
				if (typeof prop.value.value === "string") {
					const k = prop.key.type === "Identifier" && prop.key.name
					if (!k) throw new Error("Expected Identifier key in meta object for static analysis")
					const value = prop.value.value
					if (IMAGES.some((i) => value.endsWith(i))) {
						const resolved = await ctx.resolve(value, index)
						if (!resolved) continue
						const path = "./" + relative(join(process.cwd(), "src"), resolved.id)
						const name = fileNameToJSVariable(`${key}-${k}`)
						images.push([name, path])
						meta = meta.slice(0, prop.value.range![0] - start) + name + meta.slice(prop.value.range![1] - start)
					}
				}
			}
		}
	}

	return { meta, images }
}

export function fileRouter(): Plugin[] {
	const logger = createLogger("info", { prefix: "[file-router]" })
	let latestContent = ""
	const prefix = "src/pages/"
	const suffix = "/index.tsx"

	async function generate(ctx?: Context) {
		const start = Date.now()
		let count = 0
		const routePromises: Promise<Route>[] = []
		for await (const index of glob(`${prefix}**${suffix}`)) {
			count++
			const key = index.slice(prefix.length, -suffix.length)
			routePromises.push(Promise.all([key, getMeta(key, index, ctx), getGitMeta(index)]))
		}

		const routes = await Promise.all(routePromises)
		const content = template(routes)

		if (latestContent === content) return routes
		latestContent = content

		await writeFile("./src/router.ts", content)

		logger.info(`scanned ${count} routes in ${Date.now() - start} ms`, { timestamp: true })

		return routes
	}

	let routes: Route[] = []
	let dist = ""
	let ctx: Context | undefined = undefined

	return [
		{
			name: "file-router",
			enforce: "pre",
			configureServer(server) {
				const pagesDir = join(process.cwd(), "src/pages")
				const listener = (file: string) => file.startsWith(pagesDir) && file.endsWith("index.tsx") && generate(ctx)
				server.watcher.on("add", listener)
				server.watcher.on("change", listener)
				server.watcher.on("unlink", listener)
			},
			async buildStart() {
				ctx = this
				routes = await generate(this)
			},
		},
		{
			/*
			 * In "build" mode, we want to copy the index.html to the all the routes, so that
			 * a static file server can serve the routes.
			 */
			name: "file-router-post",
			enforce: "post",
			apply: "build",
			outputOptions(options) {
				dist = options.dir!
			},
			async writeBundle() {
				const html = await readFile(join(dist, "index.html"), "utf-8")
				this.info("copying index.html to routes")
				for (const [route] of routes) {
					const dir = join(dist, route)
					await mkdir(dir, { recursive: true })
					const target = join(dir, "index.html")
					await writeFile(target, html)
					this.info(target)
				}
			},
		},
	]
}
