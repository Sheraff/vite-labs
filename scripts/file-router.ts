import { createLogger, type Plugin } from 'vite'
import {
	// @ts-expect-error -- glob is not in the types yet
	glob,
	mkdir,
	readFile,
	writeFile,
} from 'node:fs/promises'
import { dirname, join, normalize } from 'node:path'
import { parseForESLint } from '@typescript-eslint/parser'
import { simpleTraverse } from '@typescript-eslint/typescript-estree'
import type { TSESLint } from '@typescript-eslint/utils'
import { exec } from "node:child_process"

type Route = [key: string, meta: string, git: string]

const template = (routes: Array<Route>) => `// generated by file-router
/* eslint-disable */
import { lazy } from "react"

export type Routes = "${routes.map(r => r[0]).join('" | "')}"

export type RouteMeta = {
	title: string
}

export type GitMeta = {
	lastModified: number
}

export type Route = {
	Component: React.LazyExoticComponent<() => JSX.Element>
	meta: RouteMeta
	git: GitMeta
}

export const ROUTES = {
${routes.map(([route, meta, git]) => `	"${route}": {
		Component: lazy(() => import("./pages/${route}/index.tsx")),
		meta: ${meta.split('\n').join('\n\t\t')},
		git: ${git},
	}`).join(',\n')}
} as const satisfies Record<Routes, Route>
`

async function getGitMeta(index: string) {
	let dates: Promise<string>[] = []
	for await (const file of glob(`${dirname(index)}/**/*`)) {
		dates.push(new Promise<string>((resolve, reject) => exec(`git log -1 --pretty="format:%ai" "${file}"`, (error, stdout, stderr) => {
			if (error || stderr) return reject(error || stderr)
			resolve(stdout.trim())
		})))
	}
	const timestamps = await Promise.all(dates)
	const max = Math.max(...timestamps.map(t => new Date(t).getTime()))
	const git = `{lastModified: ${max}}`
	return git
}

async function getMeta(key: string, index: string) {
	const source = await readFile(index, 'utf-8')
	const { ast, visitorKeys } = parseForESLint(source, {
		comment: false,
		filePath: index,
		loc: true,
		range: true,
		tokens: false,
	})
	let meta = `{ title: "${key}" }`
	const listener: TSESLint.RuleListener = ({
		ExportNamedDeclaration(node) {
			if (node.declaration?.type !== 'VariableDeclaration') return
			const decl = node.declaration.declarations[0]
			if (decl.type !== 'VariableDeclarator') return
			if (decl.id.type !== 'Identifier' || decl.id.name !== 'meta') return
			if (decl.init?.type !== 'ObjectExpression') throw new Error('Expected ObjectExpression')
			meta = source.slice(decl.init.range[0], decl.init.range[1])
		}
	})
	simpleTraverse(ast, {
		visitorKeys,
		visitors: listener as never
	})
	return meta
}

export function fileRouter(): Plugin[] {
	const logger = createLogger('info', { prefix: '[file-router]' })
	let latestContent = ''
	const prefix = 'src/pages/'
	const suffix = '/index.tsx'

	async function generate() {
		const start = Date.now()
		let count = 0
		const routePromises: Promise<Route>[] = []
		for await (const index of glob(`${prefix}*${suffix}`)) {
			count++
			const key = index.slice(prefix.length, -suffix.length)
			routePromises.push(Promise.all([key, getMeta(key, index), getGitMeta(index)]))
		}

		const routes = await Promise.all(routePromises)
		const content = template(routes)

		if (latestContent === content) return routes
		latestContent = content

		await writeFile('./src/router.ts', content)

		logger.info(`scanned ${count} routes in ${Date.now() - start} ms`, { timestamp: true })

		return routes
	}

	let routes: Route[] = []
	let dist = ''

	return [{
		name: 'file-router',
		enforce: 'pre',
		configureServer(server) {
			const pagesDir = join((process.cwd()), 'src/pages')
			const listener = (file: string) => file.startsWith(pagesDir) && file.endsWith('index.tsx') && generate()
			server.watcher.on('add', listener)
			server.watcher.on('change', listener)
			server.watcher.on('unlink', listener)
		},
		async buildStart() {
			routes = await generate()
		},
	}, {
		/*
		 * In "build" mode, we want to copy the index.html to the all the routes, so that
		 * a static file server can serve the routes.
		 */
		name: 'file-router-post',
		enforce: 'post',
		apply: 'build',
		outputOptions(options) {
			dist = options.dir!
		},
		async writeBundle() {
			const html = await readFile(join(dist, 'index.html'), 'utf-8')
			this.info('copying index.html to routes')
			for (const [route] of routes) {
				const dir = join(dist, route)
				await mkdir(dir, { recursive: true })
				const target = join(dir, 'index.html')
				await writeFile(target, html)
				this.info(target)
			}
		},
	}]
}
