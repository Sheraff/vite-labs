import { createLogger, type Plugin } from 'vite'
import {
	// @ts-expect-error -- glob is not in the types yet
	glob,
	mkdir,
	readFile,
	writeFile,
} from 'node:fs/promises'
import { dirname, join, relative } from 'node:path'
import { parseForESLint } from '@typescript-eslint/parser'
import { simpleTraverse } from '@typescript-eslint/typescript-estree'
import type { TSESLint, TSESTree } from '@typescript-eslint/utils'
import { exec } from "node:child_process"

type Image = [name: string, path: string]
type Route = [key: string, meta: { meta: string, images: Image[] }, git: string]

const template = (routes: Array<Route>) => `// generated by file-router
/* eslint-disable */
import { lazy } from "react"
${routes.map(([, { images }]) => images.map(([name, path]) => `import ${name} from "${path}"`).join('\n')).filter(Boolean).join('\n')}

export type Routes = "${routes.map(r => r[0]).join('" | "')}"

export type RouteMeta = {
	title: string
	image?: string
	description?: string
}

export type GitMeta = {
	lastModified: number
	firstAdded: number
}

export type Route = {
	Component: React.LazyExoticComponent<() => JSX.Element>
	meta: RouteMeta
	git: GitMeta
}

export const ROUTES = {
${routes.map(([route, { meta }, git]) => `	"${route}": {
		Component: lazy(() => import("./pages/${route}/index.tsx")),
		meta: ${meta.split('\n').join('\n\t\t')},
		git: ${git},
	}`).join(',\n')}
} as const satisfies Record<Routes, Route>
`

async function getGitMeta(index: string) {
	const lastAuthorTime: Promise<string>[] = []
	const firstCommit: Promise<string>[] = []
	for await (const file of glob(`${dirname(index)}/**/*`)) {
		lastAuthorTime.push(new Promise<string>(
			(resolve, reject) => exec(`git log -1 --pretty="format:%ai" "${file}"`, (error, stdout, stderr) => {
				if (error || stderr) return reject(error || stderr)
				resolve(stdout.trim())
			})
		))
		firstCommit.push(new Promise<string>(
			(resolve, reject) => exec(`git log --follow --pretty="format:%ad" "${file}" | tail -1`, (error, stdout, stderr) => {
				if (error || stderr) return reject(error || stderr)
				resolve(stdout.trim())
			})
		))
	}
	const lastModTime = await Promise.all(lastAuthorTime)
	const max = Math.max(...lastModTime.map(t => new Date(t).getTime()))

	const firstAddTime = await Promise.all(firstCommit)
	const min = Math.min(...firstAddTime.map(t => new Date(t).getTime()))

	const git = `{\n\t\t\tlastModified: ${max},\n\t\t\tfirstAdded: ${min}\n\t\t}`
	return git
}

type Context = {
	resolve: (source: string, importer?: string | undefined) => Promise<{ id: string } | null>
	addWatchFile: (id: string) => void
}

const IMAGES = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg', '.ico', '.bmp', '.tiff', '.avif']

function fileNameToJSVariable(name: string) {
	return name.replace(/[^a-zA-Z0-9]/g, '_')
}

async function getMeta(key: string, index: string, ctx?: Context) {
	let meta = `{ title: "${key}" }`
	let foundNode = false as TSESTree.ObjectExpression | false
	const images: Image[] = []
	const source = await readFile(index, 'utf-8')
	try {
		const { ast, visitorKeys } = parseForESLint(source, {
			comment: false,
			filePath: index,
			loc: true,
			range: true,
			tokens: false,
		})
		const listener: TSESLint.RuleListener = ({
			ExportNamedDeclaration(node) {
				if (foundNode) return
				if (node.declaration?.type !== 'VariableDeclaration') return
				const decl = node.declaration.declarations[0]
				if (decl.type !== 'VariableDeclarator') return
				if (decl.id.type !== 'Identifier' || decl.id.name !== 'meta') return
				if (decl.init?.type !== 'ObjectExpression') throw new Error('Expected ObjectExpression')
				foundNode = decl.init
			},
		})
		simpleTraverse(ast, {
			visitorKeys,
			visitors: listener as never,
		})
	} catch (e) {
		console.error(e)
	}
	if (foundNode) {
		const start = foundNode.range[0]
		meta = source.slice(start, foundNode.range[1])
		if (ctx?.resolve) {
			for (let i = foundNode.properties.length - 1; i >= 0; i--) {
				const prop = foundNode.properties[i]
				if (prop.type !== 'Property' || prop.value.type !== 'Literal') throw new Error('Expected Literal value in meta object for static analysis')
				if (typeof prop.value.value === 'string') {
					const k = prop.key.type === 'Identifier' && prop.key.name
					if (!k) throw new Error('Expected Identifier key in meta object for static analysis')
					const value = prop.value.value
					if (IMAGES.some(i => value.endsWith(i))) {
						const resolved = await ctx.resolve(value, index)
						if (!resolved) continue
						const path = './' + relative(join(process.cwd(), 'src'), resolved.id)
						const name = fileNameToJSVariable(`${key}-${k}`)
						images.push([name, path])
						meta = meta.slice(0, prop.value.range[0] - start) + name + meta.slice(prop.value.range[1] - start)
					}
				}
			}
		}
	}

	return { meta, images }
}

export function fileRouter(): Plugin[] {
	const logger = createLogger('info', { prefix: '[file-router]' })
	let latestContent = ''
	const prefix = 'src/pages/'
	const suffix = '/index.tsx'

	async function generate(ctx?: Context) {
		const start = Date.now()
		let count = 0
		const routePromises: Promise<Route>[] = []
		for await (const index of glob(`${prefix}*${suffix}`)) {
			count++
			const key = index.slice(prefix.length, -suffix.length)
			routePromises.push(Promise.all([key, getMeta(key, index, ctx), getGitMeta(index)]))
		}

		const routes = await Promise.all(routePromises)
		const content = template(routes)

		if (latestContent === content) return routes
		latestContent = content

		await writeFile('./src/router.ts', content)

		logger.info(`scanned ${count} routes in ${Date.now() - start} ms`, { timestamp: true })

		return routes
	}

	let routes: Route[] = []
	let dist = ''
	let ctx: Context | undefined = undefined

	return [{
		name: 'file-router',
		enforce: 'pre',
		configureServer(server) {
			const pagesDir = join((process.cwd()), 'src/pages')
			const listener = (file: string) => file.startsWith(pagesDir) && file.endsWith('index.tsx') && generate(ctx)
			server.watcher.on('add', listener)
			server.watcher.on('change', listener)
			server.watcher.on('unlink', listener)
		},
		async buildStart() {
			ctx = this
			routes = await generate(this)
		},
	}, {
		/*
		 * In "build" mode, we want to copy the index.html to the all the routes, so that
		 * a static file server can serve the routes.
		 */
		name: 'file-router-post',
		enforce: 'post',
		apply: 'build',
		outputOptions(options) {
			dist = options.dir!
		},
		async writeBundle() {
			const html = await readFile(join(dist, 'index.html'), 'utf-8')
			this.info('copying index.html to routes')
			for (const [route] of routes) {
				const dir = join(dist, route)
				await mkdir(dir, { recursive: true })
				const target = join(dir, 'index.html')
				await writeFile(target, html)
				this.info(target)
			}
		},
	}]
}
